#!/bin/bash

# Server Setup Script Template for PakProperty App
# This script prepares the server environment before deployment
#
# IMPORTANT: Before using this script:
# 1. Copy this file to setup-server.sh
# 2. Update the server configuration below with your actual server details
# 3. This template file is safe to commit to version control

# Server Configuration - UPDATE THESE VALUES
SERVER_IP="YOUR_SERVER_IP"
SERVER_USER="YOUR_SERVER_USER"
SERVER_PASSWORD="YOUR_SERVER_PASSWORD"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to execute remote commands
execute_remote() {
    sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no "$SERVER_USER@$SERVER_IP" "$1"
}

print_status "Setting up server environment for PakProperty app..."

# Update system packages
print_status "Updating system packages..."
execute_remote "apt-get update && apt-get upgrade -y"

# Install essential packages
print_status "Installing essential packages..."
execute_remote "apt-get install -y curl wget git nginx certbot python3-certbot-nginx ufw"

# Configure firewall
print_status "Configuring firewall..."
execute_remote "ufw --force enable"
execute_remote "ufw allow ssh"
execute_remote "ufw allow 80"
execute_remote "ufw allow 443"
execute_remote "ufw allow 3000"
execute_remote "ufw allow 5001"
execute_remote "ufw allow 8081"

# Install Docker
print_status "Installing Docker..."
execute_remote "curl -fsSL https://get.docker.com -o get-docker.sh && sh get-docker.sh"
execute_remote "usermod -aG docker \$USER"

# Install Docker Compose
print_status "Installing Docker Compose..."
execute_remote "curl -L \"https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose"
execute_remote "chmod +x /usr/local/bin/docker-compose"

# Create application directory
print_status "Creating application directory..."
execute_remote "mkdir -p /opt/pakproperty"

# Set up log rotation
print_status "Setting up log rotation..."
execute_remote "cat > /etc/logrotate.d/pakproperty << 'EOF'
/opt/pakproperty/logs/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    create 644 root root
}
EOF"

# Create logs directory
execute_remote "mkdir -p /opt/pakproperty/logs"

# Set up systemd service for auto-restart
print_status "Setting up systemd service..."
execute_remote "cat > /etc/systemd/system/pakproperty.service << 'EOF'
[Unit]
Description=PakProperty Application
Requires=docker.service
After=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/pakproperty
ExecStart=/usr/local/bin/docker-compose up -d
ExecStop=/usr/local/bin/docker-compose down
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF"

# Enable the service
execute_remote "systemctl enable pakproperty.service"

# Configure nginx
print_status "Configuring Nginx..."
execute_remote "rm -f /etc/nginx/sites-enabled/default"

# Create nginx configuration for the subdomain
execute_remote "cat > /etc/nginx/sites-available/YOUR_SUBDOMAIN.YOUR_DOMAIN << 'EOF'
server {
    listen 80;
    server_name YOUR_SUBDOMAIN.YOUR_DOMAIN;

    # Redirect HTTP to HTTPS
    return 301 https://\$server_name\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name YOUR_SUBDOMAIN.YOUR_DOMAIN;

    # SSL Configuration (will be added by certbot)
    ssl_certificate /etc/letsencrypt/live/YOUR_SUBDOMAIN.YOUR_DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/YOUR_SUBDOMAIN.YOUR_DOMAIN/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection \"1; mode=block\";
    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\";

    # Client (React app)
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }

    # API (Node.js backend)
    location /api {
        proxy_pass http://localhost:5001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }

    # MongoDB Express (optional, for admin)
    location /mongo-express {
        proxy_pass http://localhost:8081;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }
}
EOF"

# Enable the site
execute_remote "ln -sf /etc/nginx/sites-available/YOUR_SUBDOMAIN.YOUR_DOMAIN /etc/nginx/sites-enabled/"

# Test nginx configuration
execute_remote "nginx -t"

# Start nginx
execute_remote "systemctl start nginx"
execute_remote "systemctl enable nginx"

# Create monitoring script
print_status "Creating monitoring script..."
execute_remote "cat > /opt/pakproperty/monitor.sh << 'EOF'
#!/bin/bash

LOG_FILE=\"/opt/pakproperty/logs/monitor.log\"
APP_DIR=\"/opt/pakproperty\"

# Log function
log() {
    echo \"\$(date '+%Y-%m-%d %H:%M:%S') - \$1\" >> \"\$LOG_FILE\"
}

# Check if services are running
check_services() {
    cd \"\$APP_DIR\"
    
    if ! docker-compose ps | grep -q \"Up\"; then
        log \"Services are down, restarting...\"
        docker-compose down
        docker-compose up -d
        log \"Services restarted\"
    else
        log \"All services are running\"
    fi
}

# Check disk space
check_disk() {
    DISK_USAGE=\$(df / | awk 'NR==2 {print \$5}' | sed 's/%//')
    if [ \"\$DISK_USAGE\" -gt 80 ]; then
        log \"Warning: Disk usage is \$DISK_USAGE%\"
    fi
}

# Check memory usage
check_memory() {
    MEMORY_USAGE=\$(free | awk 'NR==2{printf \"%.2f\", \$3*100/\$2}')
    if (( \$(echo \"\$MEMORY_USAGE > 80\" | bc -l) )); then
        log \"Warning: Memory usage is \$MEMORY_USAGE%\"
    fi
}

# Main execution
log \"Starting health check\"
check_services
check_disk
check_memory
log \"Health check completed\"
EOF"

execute_remote "chmod +x /opt/pakproperty/monitor.sh"

# Add to crontab for monitoring
execute_remote "crontab -l 2>/dev/null | { cat; echo \"*/5 * * * * /opt/pakproperty/monitor.sh\"; } | crontab -"

# Create backup script
print_status "Creating backup script..."
execute_remote "cat > /opt/pakproperty/backup.sh << 'EOF'
#!/bin/bash

BACKUP_DIR=\"/opt/pakproperty/backups\"
DATE=\$(date +%Y%m%d_%H%M%S)
BACKUP_FILE=\"pakproperty_backup_\$DATE.tar.gz\"

mkdir -p \"\$BACKUP_DIR\"

# Stop services
cd /opt/pakproperty
docker-compose down

# Create backup
tar -czf \"\$BACKUP_DIR/\$BACKUP_FILE\" \
    --exclude=node_modules \
    --exclude=.git \
    --exclude=backups \
    --exclude=logs \
    .

# Start services
docker-compose up -d

# Keep only last 7 backups
cd \"\$BACKUP_DIR\"
ls -t | tail -n +8 | xargs -r rm

echo \"Backup created: \$BACKUP_FILE\"
EOF"

execute_remote "chmod +x /opt/pakproperty/backup.sh"

# Add daily backup to crontab
execute_remote "crontab -l 2>/dev/null | { cat; echo \"0 2 * * * /opt/pakproperty/backup.sh\"; } | crontab -"

print_status "Server setup completed successfully!"
print_status "The server is now ready for deployment."
print_status "You can now run the deploy.sh script to deploy the application." 